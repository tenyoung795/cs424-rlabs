const unsigned int ON_THRESHOLD = 40;
const unsigned int OFF_THRESHOLD = 62;
const string STATUS_STRINGS[] = {"forward", "backward", "correcting", "done"};

//#define USE_MOTOR true

task main() {
    #ifdef USE_MOTOR
    ResetTachoCount(OUT_BC);
    OnFwdSync(OUT_BC, 75, 0);
    #endif

    SetSensorLight(IN_3);

    #ifdef USE_MOTOR
    long lastmotorB = 0;
    long lastmotorC = 0;
    #endif

    enum TurnDirection {
        LEFT = 0,
        RIGHT = 1,
    };

    enum Status {
        FORWARD,
        BACKWARD,
        CORRECTED_FORWARD,
        DONE,
    };

    unsigned int previousScaleLight = 0;
    TurnDirection turnDirection = LEFT;
    Status status = FORWARD;
    bool turning = false;
    while (true) {
        ClearScreen();

        unsigned int rawLight = SensorValueRaw(IN_3);
		unsigned int scaleLight = SensorValue(IN_3);

        switch (status) {
        case FORWARD:
        case CORRECTED_FORWARD: {
            if (scaleLight < ON_THRESHOLD) {
                // If we got back enough on the tape while turning, then we have
                // made a successful turn.
                if (turning) {
                    turning = false;
                    status = FORWARD;
                }
                // Go forward.
            } else if (scaleLight < OFF_THRESHOLD) {
                // Since we generally travel in a "line," assume to turn
                // opposite the previous turn direction.
                if (!turning) {
                    turnDirection = !turnDirection;
                    turning = true;
                }
                const float threshold = OFF_THRESHOLD;
                float ratio_off = (OFF_THRESHOLD - scaleLight) / threshold;
                // Turn based on the ratio off the tape.
            } else if (status == FORWARD) {
                // We've made a bad turn; go back.
                status = BACKWARD;
            } else {
                // Our corrective turn was also bad, meaning we've reached the end.
                status = DONE;
            }
            break;
        }
        case BACKWARD:
            if (scaleLight < ON_THRESHOLD) {
                // Make the corrective turn.
                turning = false;
                status = CORRECTED_FORWARD;
            } else {
                // Go backward.
            }
            break;
        case DONE:
            break;
        }
        previousScaleLight = scaleLight;

        #ifdef USE_MOTOR
        long motorB = MotorTachoCount(OUT_B);
        long motorC = MotorTachoCount(OUT_C);

        long deltamotorB = motorB - lastmotorB;
        long deltamotorC = motorC - lastmotorC;

        lastmotorB = motorB;
        lastmotorC = motorC;

        // Line 0
        TextOut(0,0,"OUTB");
        TextOut(50,0,"OUTC");

        // Line 1
        NumOut(0,8,motorB);
        NumOut(50,8,motorC);

        // Line 2
        NumOut(0,16,deltamotorB);
        NumOut(50,16,deltamotorC);
        #endif

        if (!turning) {
            TextOut(0, 24, "^");
        } else if (turnDirection == LEFT) {
            TextOut(0, 24, "<-");
        } else {
            TextOut(0, 24, "->");
        }
        TextOut(50, 24, STATUS_STRINGS[status]);

        TextOut(0,32,"IN3");
        NumOut(0,40,rawLight);
        NumOut(0,48,scaleLight);

        // Line 7
        NumOut(0,56,(CurrentTick()-FirstTick())/1000);
        Wait(100);
    }
}
