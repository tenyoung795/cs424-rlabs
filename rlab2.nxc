enum Direction {
    RIGHT = 0,
    UP = 1,
    LEFT = 2,
    DOWN = 3,
};

enum Orientation {
    HORIZONTAL,
    VERTICAL,
};

const byte IMPOSSIBLE = UCHAR_MAX;
const byte WIDTH = 12;
const byte HEIGHT = 12;
const byte AREA = WIDTH * HEIGHT;
const Direction DIRECTION = 1;
const char ORIGIN_X = 0, ORIGIN_Y = 0;
const char DESTINATION_X = 11, DESTINATION_Y = 11;

struct Node {
    Direction parent;
    byte g;
    byte h;
    bool enqueued;
    bool visited;
    bool obstacle;
};

struct Point {
    char x;
    char y;
};

byte index(Point point) {
    return point.x * WIDTH + point.y;
}

#define AT_MAT(mat, point) mat[index((point))]

void initMatrix(Node &mat[]) {
    Point p;
    for (p.x = 0; p.x < WIDTH; ++p.x) {
        for (p.y = 0; p.y < HEIGHT; ++p.y) {
            AT_MAT(mat, p).g = UCHAR_MAX;
            AT_MAT(mat, p).h = abs(p.x - DESTINATION_X) + abs(p.y - DESTINATION_Y);
            AT_MAT(mat, p).enqueued = false;
            AT_MAT(mat, p).visited = false;
        }
    }
}

byte nodeF(const Node &node) {
    return node.g + node.h;
}

Point locateMinF(const Node &mat[]) {
    Point result;
    result.x = WIDTH;
    result.y = HEIGHT;
    byte minF = UCHAR_MAX;
    Point p;
    for (p.x = 0; p.x < WIDTH; ++p.x) {
        for (p.y = 0; p.y < HEIGHT; ++p.y) {
            if (!AT_MAT(mat, p).enqueued) continue;
            byte f = nodeF(AT_MAT(mat, p));
            if (f < minF) {
                result = p;
                minF = f;
            }
        }
    }
    return result;
}

Orientation orientation(Direction direction) {
    switch (direction) {
    case RIGHT:
    case LEFT:
        return HORIZONTAL;
    case UP:
    case DOWN:
        return VERTICAL;
    }
}

byte cost(Direction from, Direction to) {
    return orientation(from) == orientation(to)
        ? (from == to ? 0 : 2)
        : 1;
}

Direction flip(Direction direction) {
    switch (direction) {
    case RIGHT:
        return LEFT;
    case UP:
        return DOWN;
    case LEFT:
        return RIGHT;
    case DOWN:
        return UP;
    }
}

Point move(Point point, Direction direction) {
    switch (direction) {
    case RIGHT:
        ++point.x;
        break;
    case UP:
        ++point.y;
        break;
    case LEFT:
        --point.x;
        break;
    case DOWN:
        --point.y;
        break;
    }
    return point;
}

void checkNeighbor(Direction currentDirection, Node &mat[], Point point, Direction neighborDirection) {
    point = move(point, neighborDirection);
    if (!AT_MAT(mat, point).visited) {
        AT_MAT(mat, point).parent = flip(neighborDirection);
        AT_MAT(mat, point).g = cost(currentDirection, neighborDirection);
        AT_MAT(mat, point).enqueued = true;
    }
}

int aStar(Direction &path[], Node &mat[], Point origin, Direction direction) {
    AT_MAT(mat, origin).g = 0;
    AT_MAT(mat, origin).enqueued = true;

    bool foundDestination = false;
    byte queueSize = 1;
    while (queueSize > 0) {
        Point point = locateMinF(mat);
        AT_MAT(mat, point).enqueued = false;
        AT_MAT(mat, point).visited = true;
        --queueSize;

        if (point.x == DESTINATION_X && point.y == DESTINATION_Y) {
            foundDestination = true;
        } else {
            if (point.x < WIDTH - 1) {
                checkNeighbor(direction, mat, point, RIGHT);
            }
            if (point.y < HEIGHT - 1) {
                checkNeighbor(direction, mat, point, UP);
            }
            if (point.x > 0) {
                checkNeighbor(direction, mat, point, LEFT);
            }
            if (point.y > 0) {
                checkNeighbor(direction, mat, point, DOWN);
            }
        }
    }

    if (!foundDestination) return IMPOSSIBLE;

    int pathLength = 0;
    Point point;
    point.x = DESTINATION_X;
    point.y = DESTINATION_Y;
    while (point.x != origin.x || point.y != origin.y) {
        Direction parent = AT_MAT(mat, point).parent;
        path[pathLength] = flip(parent);
        point = move(point, parent);
        ++pathLength;
    }
    return pathLength;
}

void displayMatrix(const Node &mat[], Point origin, int pathLength, const Direction &path[]) {
    ClearScreen();
    for (byte x = 0; x < WIDTH; ++x) {
        for (byte y = 0; y < HEIGHT; ++y) {
            RectOut(x * 4, 5 + y * 4, 4, 4, DRAW_OPT_POLYGON_POLYLINE);
        }
    }
}

task display() {
    while (true) {
        ClearScreen();
        TextOut(0, 0, "A tachos");
        NumOut(0, 8, MotorTachoCount(OUT_A));
        Wait(100);
    }
}

task main() {
    /*
    ResetTachoCount(OUT_AC);
    OnFwd(OUT_A, 60);
    OnRev(OUT_C, 60);
    
    start display;
    while (MotorTachoCount(OUT_A) < 140);
    Off(OUT_AC);

    ResetTachoCount(OUT_AC);
    OnFwd(OUT_AC, 90);
    while (MotorTachoCount(OUT_A) < 425);
    Off(OUT_AC);
    */
    Node matrix[AREA];
    initMatrix(matrix);
    Point origin;
    origin.x = ORIGIN_X;
    origin.y = ORIGIN_Y;
    Direction path[AREA];
    displayMatrix(matrix, origin, aStar(path, matrix, origin, DIRECTION), path);
    while (true) { }
}
