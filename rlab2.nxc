enum Direction {
    RIGHT = 0,
    UP = 1,
    LEFT = 2,
    DOWN = 3,
};

enum Orientation {
    HORIZONTAL,
    VERTICAL,
};

const byte WIDTH = 12;
const byte HEIGHT = 12;
const byte AREA = WIDTH * HEIGHT;
const Direction DIRECTION = 1;
const char ORIGIN_X = 0, ORIGIN_Y = 0;
const char DESTINATION_X = 11, DESTINATION_Y = 11;

struct Node {
    Direction parent;
    byte g;
    byte h;
    bool enqueued;
    bool visited;
    bool obstacle;
};

struct Point {
    char x;
    char y;
};

byte index(Point point) {
    return point.x * WIDTH + point.y;
}

#define AT_MAT(mat, point) mat[index((point))]

void initMatrix(Node &mat[]) {
    Point p;
    for (p.x = 0; p.x < WIDTH; ++p.x) {
        for (p.y = 0; p.y < HEIGHT; ++p.y) {
            AT_MAT(mat, p).g = UCHAR_MAX;
            AT_MAT(mat, p).h = abs(p.x - DESTINATION_X) + abs(p.y - DESTINATION_Y);
            AT_MAT(mat, p).enqueued = false;
            AT_MAT(mat, p).visited = false;
        }
    }
}

byte nodeF(const Node &node) {
    return node.g + node.h;
}

Point locateMinF(const Node &mat[]) {
    Point result;
    result.x = WIDTH;
    result.y = HEIGHT;
    byte minF = UCHAR_MAX;
    Point p;
    for (p.x = 0; p.x < WIDTH; ++p.x) {
        for (p.y = 0; p.y < HEIGHT; ++p.y) {
            if (!AT_MAT(mat, p).enqueued) continue;
            byte f = nodeF(AT_MAT(mat, p));
            if (f < minF) {
                result = p;
                minF = f;
            }
        }
    }
    return result;
}

Orientation orientation(Direction direction) {
    switch (direction) {
    case RIGHT:
    case LEFT:
        return HORIZONTAL;
    case UP:
    case DOWN:
        return VERTICAL;
    }
}

byte cost(Direction from, Direction to) {
    return orientation(from) == orientation(to)
        ? (from == to ? 0 : 2)
        : 1;
}

Direction flip(Direction direction) {
    switch (direction) {
    case RIGHT:
        return LEFT;
    case UP:
        return DOWN;
    case LEFT:
        return RIGHT;
    case DOWN:
        return UP;
    }
}

Point move(Point point, Direction direction) {
    switch (direction) {
    case RIGHT:
        ++point.x;
        break;
    case UP:
        ++point.y;
        break;
    case LEFT:
        --point.x;
        break;
    case DOWN:
        --point.y;
        break;
    }
    return point;
}

bool checkNeighbor(Direction currentDirection, Node &mat[], Point point, Direction neighborDirection) {
    point = move(point, neighborDirection);
    if (AT_MAT(mat, point).visited) {
        return false;
    }

    byte tentativeG = cost(currentDirection, neighborDirection);
    if (tentativeG < AT_MAT(mat, point).g) {
        AT_MAT(mat, point).parent = flip(neighborDirection);
        AT_MAT(mat, point).g = tentativeG;
    }

    if (AT_MAT(mat, point).enqueued) {
        return false;
    }
    AT_MAT(mat, point).enqueued = true;
    return true;
}

int aStar(Direction &reversePath[], Node &mat[], Point origin, Direction direction) {
    AT_MAT(mat, origin).g = 0;
    AT_MAT(mat, origin).enqueued = true;

    bool foundDestination = false;
    byte queueSize = 1;
    while (queueSize > 0) {
        Point point = locateMinF(mat);
        AT_MAT(mat, point).enqueued = false;
        AT_MAT(mat, point).visited = true;
        --queueSize;

        if (point.x == DESTINATION_X && point.y == DESTINATION_Y) {
            foundDestination = true;
        } else {
            if (point.x < WIDTH - 1) {
                queueSize += checkNeighbor(direction, mat, point, RIGHT);
            }
            if (point.y < HEIGHT - 1) {
                queueSize += checkNeighbor(direction, mat, point, UP);
            }
            if (point.x > 0) {
                queueSize += checkNeighbor(direction, mat, point, LEFT);
            }
            if (point.y > 0) {
                queueSize += checkNeighbor(direction, mat, point, DOWN);
            }
        }
    }

    if (!foundDestination) return -1;

    int pathLength = 0;
    Point point;
    point.x = DESTINATION_X;
    point.y = DESTINATION_Y;
    while (point.x != origin.x || point.y != origin.y) {
        Direction parent = AT_MAT(mat, point).parent;
        reversePath[pathLength] = flip(parent);
        point = move(point, parent);
        ++pathLength;
    }
    return pathLength;
}

void displayMatrix(const Node &mat[]) {
    Point p;
    for (p.x = 0; p.x < WIDTH; ++p.x) {
        for (p.y = 0; p.y < HEIGHT; ++p.y) {
            RectOut(p.x * 4, 5 + p.y * 4, 4, 4,
                    AT_MAT(mat, p).obstacle
                    ? DRAW_OPT_FILL_SHAPE
                    : DRAW_OPT_POLYGON_POLYLINE);
        }
    }
}

void displayPath(Point origin, Direction direction,
                 int pathLength, const Direction &reversePath[]) {
    // Draws a < in the starting direction.
    switch (direction) {
    case RIGHT:
        LineOut(5 + origin.x * 4, 5 + origin.y * 4,
                origin.x * 4, 2 + origin.y * 4);
        LineOut(origin.x * 4, 2 + origin.y * 4,
                5 + origin.x * 4, 5 + origin.y * 4);
        break;
    case UP:
        LineOut(origin.x * 4, origin.y * 4,
                2 + origin.x * 4, 5 + origin.y * 4);
        LineOut(2 + origin.x * 4, 5 + origin.y * 4,
                5 + origin.x * 4, origin.y * 4);
        break;
    case LEFT:
        LineOut(origin.x * 4, 5 + origin.y * 4,
                5 + origin.x * 4, 2 + origin.y * 4);
        LineOut(5 + origin.x * 4, 2 + origin.y * 4,
                origin.x * 4, 5 + origin.y * 4);
        break;
    case DOWN:
        LineOut(origin.x * 4, 5 + origin.y * 4,
                2 + origin.x * 4, origin.y * 4);
        LineOut(2 + origin.x * 4, origin.y * 4,
                5 + origin.x * 4, 5 + origin.y * 4);
        break;
    }

    // Avoid drawing the X if no path is possible.
    if (pathLength < 0) return;

    Point p = origin;
    for (int i = pathLength - 1; i >= 0; --i) {
        p = move(p, reversePath[i]);
        PointOut(2 + p.x * 4, 2 + p.y * 4);
    }

    // Draws an X at the destination.
    LineOut(p.x * 4, p.y * 4,
            5 + p.x * 4, 5 + p.y * 4);
    LineOut(p.x * 4, 5 + p.y * 4,
            5 + p.x * 4, p.y * 4);
}

task display() {
    while (true) {
        ClearScreen();
        TextOut(0, 0, "A tachos");
        NumOut(0, 8, MotorTachoCount(OUT_A));
        Wait(100);
    }
}

task main() {
    /*
    ResetTachoCount(OUT_AC);
    OnFwd(OUT_A, 60);
    OnRev(OUT_C, 60);
    
    start display;
    while (MotorTachoCount(OUT_A) < 140);
    Off(OUT_AC);

    ResetTachoCount(OUT_AC);
    OnFwd(OUT_AC, 90);
    while (MotorTachoCount(OUT_A) < 425);
    Off(OUT_AC);
    */
    ClearScreen();

    Node matrix[AREA];
    initMatrix(matrix);
    displayMatrix(matrix);

    Point origin;
    origin.x = ORIGIN_X;
    origin.y = ORIGIN_Y;
    Direction reversePath[AREA];
    displayPath(origin, DIRECTION,
                aStar(reversePath, matrix, origin, DIRECTION), reversePath);
    while (true) { }
}
